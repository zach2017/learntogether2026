# .github/workflows/pipeline.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
    tags: [ 'v*.*.*' ]   # e.g., v1.2.3 -> triggers stage/prod path
  pull_request:
    branches: [ main ]

# Reusable variables
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}   # ghcr.io/owner/repo
  NODE_VERSION: '20'

permissions:
  contents: read
  packages: write  # needed to push to GHCR
  id-token: write  # if you later switch to cloud OIDC deploys

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

jobs:
  lint:
    name: Lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Use Node ${{ env.NODE_VERSION }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - name: Install deps
        run: npm ci

      - name: Lint
        run: |
          npm run lint --if-present
          # Or: npx eslint . --max-warnings=0

  build:
    name: Build
    runs-on: ubuntu-latest
    needs: [lint]
    steps:
      - uses: actions/checkout@v4

      - name: Use Node ${{ env.NODE_VERSION }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - name: Install deps
        run: npm ci

      - name: Build
        run: npm run build --if-present

      - name: Upload build artifacts (optional)
        uses: actions/upload-artifact@v4
        with:
          name: web-dist
          path: |
            dist
            build
          if-no-files-found: ignore

  test:
    name: Test
    runs-on: ubuntu-latest
    needs: [build]
    steps:
      - uses: actions/checkout@v4

      - name: Use Node ${{ env.NODE_VERSION }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - name: Install deps
        run: npm ci

      - name: Run tests
        run: |
          npm test --if-present -- --ci --reporters=default --reporters=jest-junit
        env:
          JEST_JUNIT_OUTPUT: junit.xml

      - name: Upload test report (optional)
        uses: actions/upload-artifact@v4
        with:
          name: junit-report
          path: junit.xml
          if-no-files-found: ignore

  docker-image:
    name: Build & Push Docker Image
    runs-on: ubuntu-latest
    needs: [test]
    env:
      # Tag scheme: sha, branch, and (if tag push) the semver
      SHA_TAG: sha-${{ github.sha }}
    steps:
      - uses: actions/checkout@v4

      - name: Set up QEMU (multi-arch optional)
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=${{ env.SHA_TAG }}
            type=ref,event=branch
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=semver,pattern={{major}}

      - name: Build & Push
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          platforms: linux/amd64
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Set image tag output
        id: img
        run: |
          # Prefer semver tag if present (when pushing a vX.Y.Z tag), else use branch, else sha
          if [[ "${GITHUB_REF_TYPE}" == "tag" && "${GITHUB_REF_NAME}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            IMG_TAG="${GITHUB_REF_NAME#v}"
          elif [[ "${GITHUB_REF_TYPE}" == "branch" ]]; then
            # sanitize branch to valid tag
            IMG_TAG="$(echo "${GITHUB_REF_NAME}" | tr '/' '-' )"
          else
            IMG_TAG="${{ env.SHA_TAG }}"
          fi
          echo "tag=${IMG_TAG}" >> "$GITHUB_OUTPUT"
          echo "image=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${IMG_TAG}" >> "$GITHUB_OUTPUT"

  deploy-dev:
    name: Deploy to Dev
    runs-on: ubuntu-latest
    needs: [docker-image]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    environment:
      name: dev
      url: ${{ steps.out-url.outputs.url || '' }}
    steps:
      - name: Prepare image ref
        id: img
        run: echo "image=${{ needs.docker-image.outputs.image || format('{0}/{1}:{2}', env.REGISTRY, env.IMAGE_NAME, 'main') }}" >> "$GITHUB_OUTPUT"

      # ====== Choose your deployment style ======
      # --- Option A: Kubernetes (apply manifests) ---
      - name: Set up kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'v1.30.0'

      - name: Write kubeconfig
        run: |
          mkdir -p ~/.kube
          echo "${KUBE_CONFIG}" | base64 -d > ~/.kube/config
        env:
          KUBE_CONFIG: ${{ secrets.KUBE_CONFIG_DEV }}

      - name: Deploy (K8s)
        run: |
          # Example patch of image in a Deployment
          kubectl -n "${NAMESPACE}" set image deploy/${DEPLOYMENT} ${CONTAINER}="${IMAGE}"
          kubectl -n "${NAMESPACE}" rollout status deploy/${DEPLOYMENT} --timeout=120s
        env:
          NAMESPACE: ${{ vars.K8S_NAMESPACE || 'dev' }}
          DEPLOYMENT: ${{ vars.K8S_DEPLOYMENT || 'web' }}
          CONTAINER: ${{ vars.K8S_CONTAINER || 'app' }}
          IMAGE: ${{ needs.docker-image.outputs.image }}
      # --- Option B: SSH + Docker Compose (comment A and uncomment below) ---
      # - name: Deploy via SSH
      #   uses: appleboy/ssh-action@v1.0.3
      #   with:
      #     host: ${{ secrets.DEV_SSH_HOST }}
      #     username: ${{ secrets.DEV_SSH_USER }}
      #     key: ${{ secrets.DEV_SSH_KEY }}
      #     script: |
      #       docker login $REGISTRY -u $GITHUB_ACTOR -p $GITHUB_TOKEN
      #       docker pull $IMAGE
      #       cd /srv/myapp && IMAGE=$IMAGE docker compose up -d
      #   env:
      #     REGISTRY: ${{ env.REGISTRY }}
      #     IMAGE: ${{ needs.docker-image.outputs.image }}
      #     GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  deploy-stage:
    name: Deploy to Stage
    runs-on: ubuntu-latest
    needs: [docker-image]
    if: startsWith(github.ref, 'refs/tags/v')
    environment:
      name: stage
      url: ${{ steps.out-url.outputs.url || '' }}
    steps:
      - name: Set up kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'v1.30.0'

      - name: Write kubeconfig
        run: |
          mkdir -p ~/.kube
          echo "${KUBE_CONFIG}" | base64 -d > ~/.kube/config
        env:
          KUBE_CONFIG: ${{ secrets.KUBE_CONFIG_STAGE }}

      - name: Deploy (K8s)
        run: |
          kubectl -n "${NAMESPACE}" set image deploy/${DEPLOYMENT} ${CONTAINER}="${IMAGE}"
          kubectl -n "${NAMESPACE}" rollout status deploy/${DEPLOYMENT} --timeout=180s
        env:
          NAMESPACE: ${{ vars.K8S_NAMESPACE_STAGE || 'stage' }}
          DEPLOYMENT: ${{ vars.K8S_DEPLOYMENT_STAGE || 'web' }}
          CONTAINER: ${{ vars.K8S_CONTAINER_STAGE || 'app' }}
          IMAGE: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.ref_name && github.ref_name != '' && github.ref_name || 'latest' }}

  deploy-prod:
    name: Deploy to Prod
    runs-on: ubuntu-latest
    needs: [deploy-stage]
    if: startsWith(github.ref, 'refs/tags/v')
    environment:
      name: prod   # set required reviewers on this environment for approval gate
      url: ${{ steps.out-url.outputs.url || '' }}
    steps:
      - name: Set up kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'v1.30.0'

      - name: Write kubeconfig
        run: |
          mkdir -p ~/.kube
          echo "${KUBE_CONFIG}" | base64 -d > ~/.kube/config
        env:
          KUBE_CONFIG: ${{ secrets.KUBE_CONFIG_PROD }}

      - name: Deploy (K8s)
        run: |
          kubectl -n "${NAMESPACE}" set image deploy/${DEPLOYMENT} ${CONTAINER}="${IMAGE}"
          kubectl -n "${NAMESPACE}" rollout status deploy/${DEPLOYMENT} --timeout=300s
        env:
          NAMESPACE: ${{ vars.K8S_NAMESPACE_PROD || 'prod' }}
          DEPLOYMENT: ${{ vars.K8S_DEPLOYMENT_PROD || 'web' }}
          CONTAINER: ${{ vars.K8S_CONTAINER_PROD || 'app' }}
          IMAGE: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.ref_name && github.ref_name != '' && github.ref_name || 'latest' }}
