<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Security+ Practice Quiz</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <meta name="color-scheme" content="light dark" />
  <style>
    /* Focus ring for accessibility */
    .kb-focus:focus-visible { outline: 3px solid rgba(59,130,246,0.8); outline-offset: 2px; border-radius: 0.5rem; }
  </style>
</head>
<body class="min-h-screen bg-gray-50 text-gray-900 antialiased">
  <main class="max-w-4xl mx-auto p-6 sm:p-10">
    <header class="mb-6 sm:mb-10">
      <h1 class="text-2xl sm:text-3xl font-bold tracking-tight">Security+ (SY0-701) Practice Quiz</h1>
      <p class="text-gray-600 mt-2">Hint on first miss • Full explanation on second miss • Five domains covered</p>
    </header>

    <!-- Progress -->
    <section aria-label="Progress" class="mb-6">
      <div class="flex items-center justify-between mb-2">
        <span id="progressText" class="text-sm font-medium text-gray-700">Question 1 of 12</span>
        <span id="scoreText" class="text-sm text-gray-600">Score: 0</span>
      </div>
      <div class="w-full bg-gray-200 rounded-full h-2">
        <div id="progressBar" class="bg-blue-600 h-2 rounded-full" style="width: 0%"></div>
      </div>
    </section>

    <!-- Card -->
    <section id="card" class="bg-white shadow-sm rounded-2xl p-5 sm:p-7">
      <div class="flex items-center gap-2 mb-4">
        <span id="domainBadge" class="inline-flex items-center text-xs font-semibold px-2.5 py-1 rounded-full bg-blue-50 text-blue-700">Domain</span>
      </div>

      <h2 id="questionText" class="text-lg sm:text-xl font-semibold leading-snug">Loading question…</h2>

      <div id="options" class="mt-5 grid gap-3"></div>

      <div id="feedback" class="mt-5 hidden">
        <div id="feedbackInner" class="rounded-xl border p-4"></div>
      </div>

      <div class="mt-6 flex items-center gap-3">
        <button id="nextBtn"
                class="kb-focus inline-flex items-center justify-center px-4 py-2.5 rounded-xl text-sm font-semibold bg-blue-600 text-white hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
                disabled>
          Next →
        </button>
        <button id="revealBtn"
                class="kb-focus hidden inline-flex items-center justify-center px-3 py-2 rounded-xl text-sm font-medium bg-gray-100 hover:bg-gray-200">
          Reveal Answer
        </button>
      </div>
    </section>

    <!-- Results -->
    <section id="results" class="hidden mt-8 bg-white shadow-sm rounded-2xl p-6">
      <h3 class="text-xl font-bold mb-2">Your Results</h3>
      <p id="finalScore" class="text-gray-700 mb-4"></p>
      <div id="domainBreakdown" class="grid sm:grid-cols-2 gap-4 mb-6"></div>
      <button id="restartBtn"
              class="kb-focus inline-flex items-center justify-center px-4 py-2.5 rounded-xl text-sm font-semibold bg-blue-600 text-white hover:bg-blue-700">
        Restart Quiz
      </button>
    </section>

    <footer class="mt-10 text-xs text-gray-500">
      Tip: Use this to drill daily. Say answers out loud to build exam speed and clarity.
    </footer>
  </main>

  <script>
    // ---------------------------
    // Question Bank (12 questions)
    // ---------------------------
    const QUESTIONS = [
      // DOMAIN 1: General Security Concepts
      {
        id: "D1-Q1",
        domain: "Domain 1: General Security Concepts",
        question: "Which part of the CIA triad ensures information is not altered in transit?",
        choices: ["Confidentiality", "Integrity", "Availability", "Non-repudiation"],
        answer: 1,
        hint: "Consider what hashing verifies.",
        explanation: "Integrity ensures data is accurate and unaltered. Hashes (e.g., SHA-256) detect changes."
      },
      {
        id: "D1-Q2",
        domain: "Domain 1: General Security Concepts",
        question: "A company adds MFA to VPN logins. Which security principle does this primarily strengthen?",
        choices: ["Authorization", "Accounting", "Authentication", "Availability"],
        answer: 2,
        hint: "Think about proving identity.",
        explanation: "MFA strengthens authentication by requiring multiple factors to prove user identity."
      },
      {
        id: "D1-Q3",
        domain: "Domain 1: General Security Concepts",
        question: "Which control type is a security guard checking IDs at a data center?",
        choices: ["Administrative, preventive", "Technical, detective", "Physical, preventive", "Compensating, corrective"],
        answer: 2,
        hint: "It's a tangible barrier.",
        explanation: "A guard is a physical control, and ID checking helps prevent unauthorized access."
      },

      // DOMAIN 2: Threats, Vulnerabilities, and Mitigations
      {
        id: "D2-Q1",
        domain: "Domain 2: Threats, Vulnerabilities, and Mitigations",
        question: "A text message pretends to be IT support and asks for your password. What attack is this?",
        choices: ["Phishing", "Vishing", "Smishing", "Pretexting"],
        answer: 2,
        hint: "Channel matters: SMS vs. email vs. phone.",
        explanation: "Smishing uses SMS messages to trick users into divulging sensitive information."
      },
      {
        id: "D2-Q2",
        domain: "Domain 2: Threats, Vulnerabilities, and Mitigations",
        question: "Which malware encrypts data and demands payment for decryption?",
        choices: ["Trojan", "Ransomware", "Rootkit", "Worm"],
        answer: 1,
        hint: "Think extortion.",
        explanation: "Ransomware encrypts files and demands payment for the decryption key."
      },
      {
        id: "D2-Q3",
        domain: "Domain 2: Threats, Vulnerabilities, and Mitigations",
        question: "Which mitigation best reduces the impact of successful ransomware?",
        choices: ["Antivirus signatures", "Daily tested offline backups", "Port knocking", "Steganography detection"],
        answer: 1,
        hint: "Focus on recovery even if prevention fails.",
        explanation: "Regular, tested offline backups enable recovery without paying attackers."
      },

      // DOMAIN 3: Security Architecture
      {
        id: "D3-Q1",
        domain: "Domain 3: Security Architecture",
        question: "Layering multiple controls so one failure doesn't expose everything is known as:",
        choices: ["Zero Trust", "Defense in Depth", "Least Privilege", "Network Address Translation"],
        answer: 1,
        hint: "Think 'backup plans' for controls.",
        explanation: "Defense in Depth stacks controls (firewalls, IDS/IPS, MFA, monitoring) for resilience."
      },
      {
        id: "D3-Q2",
        domain: "Domain 3: Security Architecture",
        question: "In cloud shared responsibility, who secures customer data stored in S3?",
        choices: ["Cloud provider only", "Customer only", "Both: provider data, customer infra", "Both: provider infra, customer data/config"],
        answer: 3,
        hint: "Provider secures the cloud; you secure what you put in it.",
        explanation: "Provider secures underlying infrastructure; the customer secures data and configurations."
      },
      {
        id: "D3-Q3",
        domain: "Domain 3: Security Architecture",
        question: "Which approach most closely aligns with 'never trust, always verify'?",
        choices: ["Implicit trust", "Air gapping", "Zero Trust", "Perimeter-only security"],
        answer: 2,
        hint: "Assume breach and verify each request.",
        explanation: "Zero Trust assumes no implicit trust; verification is continuous based on context."
      },

      // DOMAIN 4: Security Operations
      {
        id: "D4-Q1",
        domain: "Domain 4: Security Operations",
        question: "Which incident response phase isolates affected systems to prevent spread?",
        choices: ["Identification", "Containment", "Eradication", "Recovery"],
        answer: 1,
        hint: "Stop the bleeding before cleanup.",
        explanation: "Containment limits damage and prevents lateral movement."
      },
      {
        id: "D4-Q2",
        domain: "Domain 4: Security Operations",
        question: "A SIEM flags unusual outbound traffic at 03:00 from a workstation. Best immediate action?",
        choices: ["Reimage immediately", "Power off the SIEM", "Isolate the host from network", "Ignore as false positive"],
        answer: 2,
        hint: "Limit impact while preserving evidence.",
        explanation: "Isolate first to contain potential compromise; then investigate and preserve logs."
      },
      {
        id: "D4-Q3",
        domain: "Domain 4: Security Operations",
        question: "Which is critical for preserving legal admissibility of digital evidence?",
        choices: ["Full disk encryption", "Chain of custody", "File compression", "Log rotation"],
        answer: 1,
        hint: "Documentation of who handled what, when.",
        explanation: "Chain of custody documents collection, handling, transfer, and storage of evidence."
      },

      // DOMAIN 5: Program Management & Oversight
      {
        id: "D5-Q1",
        domain: "Domain 5: Security Program Management and Oversight",
        question: "Which US regulation protects healthcare PHI?",
        choices: ["SOX", "HIPAA", "GDPR", "ISO 27001"],
        answer: 1,
        hint: "Think hospitals and clinics.",
        explanation: "HIPAA governs protection and privacy of health information in the US."
      },
      {
        id: "D5-Q2",
        domain: "Domain 5: Security Program Management and Oversight",
        question: "An RTO of 4 hours for a database means:",
        choices: [
          "Max data loss is 4 hours",
          "Restore service within 4 hours",
          "Backups must run every 4 hours",
          "No downtime over 4 hours per year"
        ],
        answer: 1,
        hint: "Time to restore service vs. data loss.",
        explanation: "RTO (Recovery Time Objective) is the maximum acceptable downtime; service should be restored within 4 hours."
      }
    ];

    // Shuffle questions for variety
    function shuffle(arr) {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    // State
    let questions = shuffle(QUESTIONS);
    let idx = 0;
    let attempts = 0; // attempts on current question
    let score = 0;
    const results = []; // {id, domain, correct, attempts}
    const perDomain = {}; // domain -> {correct, total}

    // Elements
    const progressText = document.getElementById("progressText");
    const scoreText = document.getElementById("scoreText");
    const progressBar = document.getElementById("progressBar");
    const domainBadge = document.getElementById("domainBadge");
    const questionText = document.getElementById("questionText");
    const optionsEl = document.getElementById("options");
    const feedback = document.getElementById("feedback");
    const feedbackInner = document.getElementById("feedbackInner");
    const nextBtn = document.getElementById("nextBtn");
    const revealBtn = document.getElementById("revealBtn");
    const resultsSection = document.getElementById("results");
    const finalScore = document.getElementById("finalScore");
    const domainBreakdown = document.getElementById("domainBreakdown");
    const restartBtn = document.getElementById("restartBtn");

    nextBtn.addEventListener("click", () => {
      idx++;
      if (idx >= questions.length) {
        showResults();
      } else {
        attempts = 0;
        render();
      }
    });

    revealBtn.addEventListener("click", () => {
      // Force show explanation & correct answer
      showExplanation(true);
    });

    restartBtn?.addEventListener("click", () => {
      questions = shuffle(QUESTIONS);
      idx = 0;
      attempts = 0;
      score = 0;
      Object.keys(perDomain).forEach(k => delete perDomain[k]);
      results.length = 0;
      resultsSection.classList.add("hidden");
      document.getElementById("card").classList.remove("hidden");
      render();
    });

    function render() {
      const q = questions[idx];
      updateProgress();
      domainBadge.textContent = q.domain;
      domainBadge.className = "inline-flex items-center text-xs font-semibold px-2.5 py-1 rounded-full bg-blue-50 text-blue-700";

      questionText.textContent = q.question;
      feedback.classList.add("hidden");
      feedbackInner.innerHTML = "";
      nextBtn.disabled = true;
      revealBtn.classList.add("hidden");

      optionsEl.innerHTML = "";
      q.choices.forEach((choice, i) => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "kb-focus text-left w-full px-4 py-3 rounded-xl border bg-white hover:bg-gray-50";
        btn.setAttribute("data-index", i);
        btn.setAttribute("aria-label", `Answer option ${String.fromCharCode(65 + i)}: ${choice}`);
        btn.innerHTML = `<span class="font-semibold mr-2">${String.fromCharCode(65 + i)}.</span>${choice}`;
        btn.addEventListener("click", onSelect);
        optionsEl.appendChild(btn);
      });
    }

    function updateProgress() {
      const total = questions.length;
      progressText.textContent = `Question ${idx + 1} of ${total}`;
      scoreText.textContent = `Score: ${score}`;
      const pct = Math.round(((idx) / total) * 100);
      progressBar.style.width = `${pct}%`;
    }

    function onSelect(e) {
      const q = questions[idx];
      const selectedIdx = Number(e.currentTarget.getAttribute("data-index"));

      // If already resolved (next enabled), ignore further clicks
      if (!nextBtn.disabled) return;

      // First: mark the chosen button visually
      const buttons = [...optionsEl.querySelectorAll("button")];
      buttons.forEach(b => b.classList.remove("ring-2", "ring-blue-400"));
      e.currentTarget.classList.add("ring-2", "ring-blue-400");

      if (selectedIdx === q.answer) {
        // Correct
        score++;
        lockOptions(selectedIdx, q.answer);
        showCorrect();
        recordResult(true);
        nextBtn.disabled = false;
      } else {
        // Incorrect
        attempts++;
        if (attempts === 1) {
          // Show hint, keep options enabled (disable the chosen wrong to guide)
          e.currentTarget.classList.add("opacity-60", "cursor-not-allowed");
          e.currentTarget.disabled = true;
          showHint(q.hint);
          revealBtn.classList.remove("hidden");
        } else {
          // Second miss => show explanation, reveal correct, lock
          lockOptions(selectedIdx, q.answer);
          showExplanation(false);
          recordResult(false);
          nextBtn.disabled = false;
        }
      }
    }

    function lockOptions(selectedIdx, correctIdx) {
      const buttons = [...optionsEl.querySelectorAll("button")];
      buttons.forEach((btn, i) => {
        btn.disabled = true;
        btn.classList.remove("hover:bg-gray-50", "ring-2", "ring-blue-400");
        if (i === correctIdx) {
          btn.classList.add("border-green-600", "bg-green-50");
        }
        if (i === selectedIdx && selectedIdx !== correctIdx) {
          btn.classList.add("border-red-600", "bg-red-50", "opacity-80");
        }
      });
    }

    function showHint(hint) {
      feedback.classList.remove("hidden");
      feedbackInner.className = "rounded-xl border border-yellow-300 bg-yellow-50 p-4";
      feedbackInner.innerHTML = `
        <div class="flex items-start gap-2">
          <span class="mt-0.5 inline-flex h-5 w-5 items-center justify-center rounded-full bg-yellow-200 text-yellow-900 text-xs font-bold">!</span>
          <div>
            <p class="font-semibold text-yellow-900">Hint</p>
            <p class="text-yellow-900/90 mt-1">${hint}</p>
            <p class="text-xs text-yellow-900/80 mt-2">Try again. You'll see the full explanation if you miss one more time.</p>
          </div>
        </div>
      `;
    }

    function showCorrect() {
      const q = questions[idx];
      feedback.classList.remove("hidden");
      feedbackInner.className = "rounded-xl border border-green-300 bg-green-50 p-4";
      feedbackInner.innerHTML = `
        <div class="flex items-start gap-2">
          <span class="mt-0.5 inline-flex h-5 w-5 items-center justify-center rounded-full bg-green-200 text-green-900 text-xs font-bold">✓</span>
          <div>
            <p class="font-semibold text-green-900">Correct</p>
            <p class="text-green-900/90 mt-1">${q.explanation}</p>
          </div>
        </div>
      `;
    }

    function showExplanation(forcedReveal) {
      const q = questions[idx];
      feedback.classList.remove("hidden");
      feedbackInner.className = "rounded-xl border border-red-300 bg-red-50 p-4";
      feedbackInner.innerHTML = `
        <div class="flex items-start gap-2">
          <span class="mt-0.5 inline-flex h-5 w-5 items-center justify-center rounded-full bg-red-200 text-red-900 text-xs font-bold">×</span>
          <div>
            <p class="font-semibold text-red-900">${forcedReveal ? "Answer Revealed" : "Incorrect (2nd attempt)"}</p>
            <p class="text-red-900/90 mt-1"><span class="font-semibold">Correct answer:</span> ${String.fromCharCode(65 + q.answer)}. ${q.choices[q.answer]}</p>
            <p class="text-red-900/90 mt-2">${q.explanation}</p>
          </div>
        </div>
      `;

      // When forcing reveal (user clicked Reveal Answer), also lock options & enable next
      if (forcedReveal) {
        const buttons = [...optionsEl.querySelectorAll("button")];
        buttons.forEach((btn, i) => {
          btn.disabled = true;
          btn.classList.remove("hover:bg-gray-50", "ring-2", "ring-blue-400");
          if (i === q.answer) btn.classList.add("border-green-600", "bg-green-50");
        });
        nextBtn.disabled = false;

        // Only record as incorrect if not yet recorded and attempts == 0 or 1
        if (!results.some(r => r.id === q.id)) {
          attempts = Math.max(attempts, 2);
          recordResult(false);
        }
      }
    }

    function recordResult(correct) {
      const q = questions[idx];
      results.push({ id: q.id, domain: q.domain, correct, attempts });
      perDomain[q.domain] = perDomain[q.domain] || { correct: 0, total: 0 };
      perDomain[q.domain].total += 1;
      if (correct) perDomain[q.domain].correct += 1;
    }

    function showResults() {
      // Fill progress bar to 100%
      progressBar.style.width = "100%";
      document.getElementById("card").classList.add("hidden");
      resultsSection.classList.remove("hidden");

      finalScore.textContent = `You answered ${score} out of ${questions.length} correctly (${Math.round((score/questions.length)*100)}%).`;

      domainBreakdown.innerHTML = "";
      Object.keys(perDomain).forEach(domain => {
        const d = perDomain[domain];
        const pct = Math.round((d.correct / d.total) * 100);
        const card = document.createElement("div");
        card.className = "rounded-xl border p-4";
        card.innerHTML = `
          <p class="font-semibold">${domain}</p>
          <p class="text-gray-700 mt-1">${d.correct} / ${d.total} correct (${pct}%)</p>
          <div class="w-full bg-gray-200 rounded-full h-2 mt-2">
            <div class="${pct >= 70 ? 'bg-green-600' : pct >= 50 ? 'bg-yellow-500' : 'bg-red-600'} h-2 rounded-full" style="width:${pct}%"></div>
          </div>
        `;
        domainBreakdown.appendChild(card);
      });
    }

    // Init
    render();
  </script>
</body>
</html>
